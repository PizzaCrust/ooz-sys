--- original
+++ modified
@@ -104,7 +104,7 @@
   //    Read byte L from |length_stream|
   //    If L > 251: L += 4 * Read word from |length_stream|
   //    L += 29
-  //    Copy L bytes from match pointed by next offset from |off32_stream|, 
+  //    Copy L bytes from match pointed by next offset from |off32_stream|,
   //    relative to start of block.
   //    Then prefetch |off32_stream[3]|
   //
@@ -114,7 +114,7 @@
   //    relative to start of block.
   //    Then prefetch |off32_stream[3]|
   const byte *cmd_stream, *cmd_stream_end;
-  
+
   // Length stream
   const byte *length_stream;

@@ -126,7 +126,7 @@

   // Far offsets for current chunk
   uint32 *off32_stream, *off32_stream_end;
-  
+
   // Holds the offsets for the two chunks
   uint32 *off32_stream_1, *off32_stream_2;
   uint32 off32_size_1, off32_size_2;
@@ -167,7 +167,7 @@
   // Array to hold the output of the huffman read array operation
   byte *output, *output_end;
   // We decode three parallel streams, two forwards, |src| and |src_mid|
-  // while |src_end| is decoded backwards. 
+  // while |src_end| is decoded backwards.
   const byte *src, *src_mid, *src_end, *src_mid_org;
   int src_bitpos, src_mid_bitpos, src_end_bitpos;
   uint32 src_bits, src_mid_bits, src_end_bits;
@@ -581,7 +581,7 @@
   int i, j;
   for(i = 0; i != 32; i++) {
     j = offsets[i];
-    t0 = _mm_unpacklo_epi8(_mm_loadl_epi64((const __m128i *)&input[j]), 
+    t0 = _mm_unpacklo_epi8(_mm_loadl_epi64((const __m128i *)&input[j]),
                            _mm_loadl_epi64((const __m128i *)&input[j + 256]));
     t1 = _mm_unpacklo_epi8(_mm_loadl_epi64((const __m128i *)&input[j + 512]),
                            _mm_loadl_epi64((const __m128i *)&input[j + 768]));
@@ -903,7 +903,7 @@
   uint8 *dst_end = dst + size;
   if (p >= p_end)
     return false;
-   
+
   int count = -(int)br->bitpos;
   uint32 v = *p++ & (255 >> br->bitpos);
   for (;;) {
@@ -1064,7 +1064,7 @@
   memset(code_len + (num_symbols + fluff), 0, 16);
   if (!DecodeGolombRiceBits(code_len, num_symbols, forced_bits, &br2))
     return -1;
-   
+
   // Reset the bits decoder.
   bits->bitpos = 24;
   bits->p = br2.p;
@@ -1128,7 +1128,7 @@
   int ranges = Huff_ConvertToRanges(range, num_symbols, fluff, &code_len[num_symbols], bits);
   if (ranges <= 0)
     return -1;
-  
+
   uint8 *cp = code_len;
   for (int i = 0; i < ranges; i++) {
     int sym = range[i].symbol;
@@ -1218,7 +1218,7 @@
     memset(output, syms[0], output_size);
     return src - src_end;
   }
-  
+
   if (!Huff_MakeLut(code_prefix_org, code_prefix, &huff_lut, syms))
     return -1;

@@ -1359,7 +1359,7 @@

   if (src_end - src < 3)
     return -1;
-  
+
   int Q = *(uint16*)src;
   src += 2;

@@ -1382,7 +1382,7 @@
   uint8 *interval_indexes = scratch_cur;
   scratch_cur += num_indexes;

- 
+
   if (Q & 0x8000) {
     int size_out;
     int n = Kraken_DecodeBytes(&interval_indexes, src, src_end, &size_out, num_indexes, false, scratch_cur, scratch_end);
@@ -1437,8 +1437,8 @@
   const uint8 *b = src_end_actual;
   uint32 bits_b = 0;
   int bitpos_b = 24;
-  

+
   int i;
   for (i = 0; i + 2 <= num_lens; i += 2) {
     bits_f |= _byteswap_ulong(*(uint32*)f) >> (24 - bitpos_f);
@@ -1668,7 +1668,7 @@
     br2.p = bits->p - ((uint)(24 - bits->bitpos + 7) >> 3);
     br2.p_end = bits->p_end;
     br2.bitpos = (bits->bitpos - 24) & 7;
-    
+
     if (!DecodeGolombRiceLengths(rice, total_rice_values, &br2))
       return false;
     memset(rice + total_rice_values, 0, 16);
@@ -1700,7 +1700,7 @@
       int num = range[ri].num;
       do {
         BitReader_Refill(bits);
-        
+
         int nextra = Q + *cur_rice_ptr++;
         if (nextra > 15)
           return false;
@@ -1711,7 +1711,7 @@
         if (v <= limit)
           v = average_div4 + (-(v & 1) ^ ((uint32)v >> 1));
         if (limit > v)
-          limit = v;  
+          limit = v;
         v += 1;
         average += limit - average_div4;
         *tanstable_A = symbol;
@@ -1941,7 +1941,7 @@
     bits_b >>= e->bits_x;                       \
     if (dst >= dst_end)                         \
       break;
-  
+
   if (dst < dst_end) {
     for (;;) {
       TANS_FORWARD_BITS();
@@ -1996,7 +1996,7 @@
   // reserved bit
   if (BitReader_ReadBitNoRefill(&br))
     return -1;
-  
+
   int L_bits = BitReader_ReadBitsNoRefill(&br, 2) + 8;

   if (!Tans_DecodeTable(&br, L_bits, &tans_data))
@@ -2224,7 +2224,7 @@
   BitReader bits_a, bits_b;
   int n, i;
   int u32_len_stream_size = 0;
-  
+
   bits_a.bitpos = 24;
   bits_a.bits = 0;
   bits_a.p = src;
@@ -2250,7 +2250,7 @@
     bits_b.bits <<= n;
     BitReader_RefillBackwards(&bits_b);
   }
-  
+
   if (multi_dist_scale == 0) {
     // Traditional way of coding offsets
     const uint8 *packed_offs_stream_end = packed_offs_stream + packed_offs_stream_size;
@@ -2261,7 +2261,7 @@
       *offs_stream++ = -(int32)BitReader_ReadDistanceB(&bits_b, *packed_offs_stream++);
     }
   } else {
-    // New way of coding offsets 
+    // New way of coding offsets
     int *offs_stream_org = offs_stream;
     const uint8 *packed_offs_stream_end = packed_offs_stream + packed_offs_stream_size;
     uint32 cmd, offs;
@@ -2286,7 +2286,7 @@
   uint32 u32_len_stream_buf[512]; // max count is 128kb / 256 = 512
   if (u32_len_stream_size > 512)
     return false;
-   
+
   uint32 *u32_len_stream = u32_len_stream_buf,
          *u32_len_stream_end = u32_len_stream_buf + u32_len_stream_size;
   for (i = 0; i + 1 < u32_len_stream_size; i += 2) {
@@ -2551,7 +2551,7 @@

 // Note: may access memory out of bounds on invalid input.
 bool Kraken_ProcessLzRuns_Type1(KrakenLzTable *lzt, byte *dst, byte *dst_end, byte *dst_start) {
-  const byte *cmd_stream = lzt->cmd_stream, 
+  const byte *cmd_stream = lzt->cmd_stream,
              *cmd_stream_end = cmd_stream + lzt->cmd_stream_size;
   const int *len_stream = lzt->len_stream;
   const int *len_stream_end = lzt->len_stream + lzt->len_stream_size;
@@ -2573,12 +2573,12 @@
     uint32 litlen = f & 3;
     uint32 offs_index = f >> 6;
     uint32 matchlen = (f >> 2) & 0xF;
-  
+
     // use cmov
     uint32 next_long_length = *len_stream;
     const int *next_len_stream = len_stream + 1;

-    len_stream = (litlen == 3) ? next_len_stream : len_stream; 
+    len_stream = (litlen == 3) ? next_len_stream : len_stream;
     litlen = (litlen == 3) ? next_long_length : litlen;
     recent_offs[6] = *offs_stream;

@@ -2605,7 +2605,7 @@
     recent_offs[offs_index + 2] = recent_offs[offs_index + 1];
     recent_offs[offs_index + 1] = recent_offs[offs_index + 0];
     recent_offs[3] = offset;
-    
+
     offs_stream = (int*)((intptr_t)offs_stream + ((offs_index + 1) & 4));

     if ((uintptr_t)offset < (uintptr_t)(dst_start - dst))
@@ -2892,7 +2892,7 @@

   finline LeviathanModeRaw(LeviathanLzTable *lzt, uint8 *dst_start) : lit_stream(lzt->lit_stream[0]) {
   }
-  
+
   finline bool CopyLiterals(uint32 cmd, uint8 *&dst, const int *&len_stream, uint8 *match_zone_end, size_t last_offset) {
     uint32 litlen = (cmd >> 3) & 3;
     // use cmov
@@ -2992,7 +2992,7 @@
 struct LeviathanModeLamSub {
   const uint8 *lit_stream, *lam_lit_stream;

-  finline LeviathanModeLamSub(LeviathanLzTable *lzt, uint8 *dst_start) 
+  finline LeviathanModeLamSub(LeviathanLzTable *lzt, uint8 *dst_start)
     : lit_stream(lzt->lit_stream[0]),
       lam_lit_stream(lzt->lit_stream[1]) {
   }
@@ -3008,7 +3008,7 @@
     const int *next_len_stream = len_stream + 1;
     len_stream = (litlen == 3) ? next_len_stream : len_stream;
     litlen = (litlen == 3) ? len_stream_value : litlen;
-       
+
     if (litlen-- == 0)
       return false; // lamsub mode requires one literal

@@ -3094,7 +3094,7 @@
 struct LeviathanModeSubAndF {
   enum { NUM = 16, MASK = NUM - 1};
   const uint8 *lit_stream[NUM];
-  
+
   finline LeviathanModeSubAndF(LeviathanLzTable *lzt, uint8 *dst_start) {
     for(size_t i = 0; i != NUM; i++)
       lit_stream[i] = lzt->lit_stream[(-(intptr_t)dst_start + i) & MASK];
@@ -3133,7 +3133,7 @@
 struct LeviathanModeO1 {
   const uint8 *lit_streams[16];
   uint8 next_lit[16];
-  
+
   finline LeviathanModeO1(LeviathanLzTable *lzt, uint8 *dst_start) {
     for (size_t i = 0; i != 16; i++) {
       uint8 *p = lzt->lit_stream[i];
@@ -3188,7 +3188,7 @@
               *cmd_stream_end = cmd_stream + lzt->cmd_stream_size;
   const int *len_stream = lzt->len_stream;
   const int *len_stream_end = len_stream + lzt->len_stream_size;
-  
+
   const int *offs_stream = lzt->offs_stream;
   const int *offs_stream_end = offs_stream + lzt->offs_stream_size;
   const byte *copyfrom;
@@ -3214,7 +3214,7 @@

   for(;;) {
     uint32 cmd;
-    
+
     if (!MultiCmd) {
       if (cmd_stream >= cmd_stream_end)
         break;
@@ -3294,7 +3294,7 @@
   uint8 *dst_cur = dst + (offset == 0 ? 8 : 0);
   uint8 *dst_end = dst + dst_size;
   uint8 *dst_start = dst - offset;
-  
+
   if (lzt->cmd_stream != NULL) {
     // single cmd mode
     switch (chunk_type) {
@@ -3467,7 +3467,7 @@
   lz->cmd_stream = out;
   lz->cmd_stream_end = out + decode_count;
   scratch += decode_count;
-  
+
   lz->cmd_stream_2_offs_end = decode_count;
   if (dst_size <= 0x10000) {
     lz->cmd_stream_2_offs = decode_count;
@@ -3783,7 +3783,7 @@
         return NULL;
       match = dst_begin - *off32_stream++;
       recent_offs = (match - dst);
-      
+
       if (dst_end - dst < length)
         return NULL;
       COPY_64(dst, match);
@@ -3830,7 +3830,7 @@
       }
       length_stream += 1;
       length += 91;
-      
+
       if (off16_stream == off16_stream_end)
         return NULL;
       match = dst - *off16_stream++;
@@ -3860,7 +3860,7 @@
         return NULL;
       match = dst_begin - *off32_stream++;
       recent_offs = (match - dst);
-      
+
       do {
         COPY_64(dst, match);
         COPY_64(dst + 8, match + 8);
@@ -3900,7 +3900,7 @@
                            const byte *src, const byte *src_end,
                            byte *dst, size_t dst_size, uint64 offset, byte *dst_end,
                            MermaidLzTable *lz) {
-  
+
   int iteration = 0;
   byte *dst_start = dst - offset;
   int32 saved_dist = -8;
@@ -3909,7 +3909,7 @@
   for (iteration = 0; iteration != 2; iteration++) {
     size_t dst_size_cur = dst_size;
     if (dst_size_cur > 0x10000) dst_size_cur = 0x10000;
-    
+
     if (iteration == 0) {
       lz->off32_stream = lz->off32_stream_1;
       lz->off32_stream_end = lz->off32_stream_1 + lz->off32_size_1 * 4;
@@ -3922,7 +3922,7 @@
     }

     if (mode == 0) {
-      src_cur = Mermaid_Mode0(dst, dst_size_cur, dst_end, dst_start, src_end, lz, &saved_dist, 
+      src_cur = Mermaid_Mode0(dst, dst_size_cur, dst_end, dst_start, src_end, lz, &saved_dist,
         (offset == 0) && (iteration == 0) ? 8 : 0);
     } else {
       src_cur = Mermaid_Mode1(dst, dst_size_cur, dst_end, dst_start, src_end, lz, &saved_dist,
@@ -4013,7 +4013,7 @@
   if (offset >= 8) {
     for (; i + 8 <= length; i += 8)
       *(uint64*)(dst + i) = *(uint64*)(src + i);
-  } 
+  }
   for (; i < length; i++)
     dst[i] = src[i];
 }
@@ -4061,7 +4061,7 @@
     dec->src_used = dec->dst_used = 0;
     return true;
   }
-  
+
   if (qhdr.compressed_size > (uint32)dst_bytes_left)
     return false;

@@ -4127,8 +4127,14 @@
   dec->dst_used = dst_bytes_left;
   return true;
 }
-  
-int Kraken_Decompress(const byte *src, size_t src_len, byte *dst, size_t dst_len) {
+
+#if defined(_MSC_VER)
+    #define EXPORT extern "C" __declspec(dllexport)
+#elif defined(__GNUC__)
+    #define EXPORT extern "C" __attribute__((visibility("default")))
+#endif
+
+EXPORT int Kraken_Decompress(const byte *src, size_t src_len, byte *dst, size_t dst_len) {
   KrakenDecoder *dec = Kraken_Create();
   int offset = 0;
   while (dst_len != 0) {
@@ -4252,9 +4258,9 @@
       case 'm':
         c = *s++;
         arg_compressor = (c == 'k') ? kCompressor_Kraken :
-                         (c == 'm') ? kCompressor_Mermaid : 
-                         (c == 's') ? kCompressor_Selkie : 
-                         (c == 'l') ? kCompressor_Leviathan : 
+                         (c == 'm') ? kCompressor_Mermaid :
+                         (c == 's') ? kCompressor_Selkie :
+                         (c == 'l') ? kCompressor_Leviathan :
                          (c == 'h') ? kCompressor_Hydra : -1;
         if (arg_compressor < 0)
           return -1;
@@ -4340,141 +4346,7 @@
 int CompressBlock(int codec_id, uint8 *src_in, uint8 *dst_in, int src_size, int level,
                   const CompressOptions *compressopts, uint8 *src_window_base, LRMCascade *lrm);

-int main(int argc, char *argv[]) {
-  int64_t start, end, freq;
-  int argi;
-
-  if (argc < 2 || 
-      (argi = ParseCmdLine(argc, argv)) < 0 || 
-      argi >= argc ||  // no files
-      (arg_direction != 'b' && (argc - argi) > 2) ||  // too many files
-      (arg_direction == 't' && (argc - argi) != 2)     // missing argument for verify
-      ) {
-    fprintf(stderr, "ooz v7.1 - compressor by Rarten\n\n"
-      "Usage: ooz [options] input [output]\n"
-      " -c --stdout              write to stdout\n"
-      " -d --decompress          decompress (default)\n"
-      " -z --compress            compress\n"
-      " -b                       just benchmark, don't overwrite anything\n"
-      " -f                       force overwrite existing file\n"
-      " --dll                    decompress with the dll\n"
-      " --verify                 decompress and verify that it matches output\n"
-      " --verify=<folder>        verify with files in this folder\n"
-      " -<1-9> --level=<-4..10>  compression level\n"
-      " -m<k>                    [k|m|s|l|h] compressor selection\n"
-      " --kraken --mermaid --selkie --leviathan --hydra    compressor selection\n\n"
-      "(Warning! not fuzz safe, so please trust the input)\n"
-      );
-    return 1;
-  }
-  bool write_mode = (argi + 1 < argc) && (arg_direction != 't' && arg_direction != 'b');
-
-  if (!arg_force && write_mode) {
-    struct stat sb;
-    if (stat(argv[argi + 1], &sb) >= 0) {
-      fprintf(stderr, "file %s already exists, skipping.\n", argv[argi + 1]);
-      return 1;
-    }
-  }
-
-  int nverify = 0;
-
-  for (; argi < argc; argi++) {
-    const char *curfile = argv[argi];
-
-    int input_size;
-    byte *input = load_file(curfile, &input_size);
-
-    byte *output = NULL;
-    int outbytes = 0;
-
-    if (arg_direction == 'z') {
-      // compress using the dll
-      if (arg_dll)
-        LoadLib();
-      output = new byte[input_size + 65536];
-      if (!output) error("memory error", curfile);
-      *(uint64*)output = input_size;
-      QueryPerformanceCounter((LARGE_INTEGER*)&start);
-      if (arg_dll) {
-        outbytes = OodLZ_Compress(arg_compressor, input, input_size, output + 8, arg_level, 0, 0, 0, 0, 0);
-      } else {
-        outbytes = CompressBlock(arg_compressor, input, output + 8, input_size, arg_level, 0, 0, 0);
-      }
-      if (outbytes < 0) error("compress failed", curfile);
-      outbytes += 8;
-      QueryPerformanceCounter((LARGE_INTEGER*)&end);
-      QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
-      double seconds = (double)(end - start) / freq;
-      if (!arg_quiet)
-        fprintf(stderr, "%-20s: %8d => %8d (%.2f seconds, %.2f MB/s)\n", argv[argi], input_size, outbytes, seconds, input_size * 1e-6 / seconds);
-    } else {
-      if (arg_dll)
-        LoadLib();
-
-      // stupidly attempt to autodetect if file uses 4-byte or 8-byte header,
-      // the previous version of this tool wrote a 4-byte header.
-      int hdrsize = *(uint64*)input >= 0x10000000000 ? 4 : 8;
-      
-      uint64 unpacked_size = (hdrsize == 8) ? *(uint64*)input : *(uint32*)input;
-      if (unpacked_size > (hdrsize == 4 ? 52*1024*1024 : 1024 * 1024 * 1024)) 
-        error("file too large", curfile);
-      output = new byte[unpacked_size + SAFE_SPACE];
-      if (!output) error("memory error", curfile);
-
-      QueryPerformanceCounter((LARGE_INTEGER*)&start);
-
-      if (arg_dll) {
-        outbytes = OodLZ_Decompress(input + hdrsize, input_size - hdrsize, output, unpacked_size, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
-      } else {
-        outbytes = Kraken_Decompress(input + hdrsize, input_size - hdrsize, output, unpacked_size);
-      }
-      if (outbytes != unpacked_size)
-        error("decompress error", curfile);
-      QueryPerformanceCounter((LARGE_INTEGER*)&end);
-      QueryPerformanceFrequency((LARGE_INTEGER*)&freq);
-      double seconds = (double)(end - start) / freq;
-      if (!arg_quiet)
-        fprintf(stderr, "%-20s: %8d => %8d (%.2f seconds, %.2f MB/s)\n", argv[argi], input_size, (int)unpacked_size, seconds, unpacked_size * 1e-6 / seconds);
-    }
-
-    if (verifyfolder) {
-      // Verify against the file in verifyfolder with the same basename excluding extension
-      char buf[1024];
-      const char *basename = curfile;
-      for(const char *s = curfile; *s; s++)
-        if (*s == '/' || *s == '\\')
-          basename = s + 1;
-      const char *ext = strrchr(basename, '.');
-      snprintf(buf, sizeof(buf), "%s/%.*s", verifyfolder, (int)(ext ? (ext - basename) : strlen(basename)), basename);
-      if (!Verify(buf, output, outbytes, curfile))
-        return 1;
-      nverify++;
-    }
-
-    if (arg_stdout && arg_direction != 't' && arg_direction != 'b')
-      fwrite(output, 1, outbytes, stdout);
-
-    if (write_mode) {
-      if (arg_direction == 't') {
-        if (!Verify(argv[argi + 1], output, outbytes, curfile))
-          return 1;
-        fprintf(stderr, "%s: Verify OK\n", curfile);
-      } else {
-        FILE *f = fopen(argv[argi + 1], "wb");
-        if (!f) error("file open for write error", argv[argi + 1]);
-        if (fwrite(output, 1, outbytes, f) != outbytes)
-          error("file write error", argv[argi + 1]);
-        fclose(f);
-      }
-      break;
-    }
-    delete[] input;
-    delete[] output;
-  }
-
-  if (nverify)
-    fprintf(stderr, "%d files verified OK!\n", nverify);
-  return 0;
-}
-
+EXPORT int Compress(int codec_id, uint8 *src_in, uint8 *dst_in, int src_size, int level,
+             const CompressOptions *compressopts, uint8 *src_window_base, LRMCascade *lrm) {
+    return CompressBlock(codec_id, src_in, dst_in, src_size, level, compressopts, src_window_base, lrm);
+}
\ No newline at end of file
